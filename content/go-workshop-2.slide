Go Workshop - Dia 2
https://golang-workshop.io
Tags: golang

Rodolfo Finochietti
[[https://rodolfofinochietti.me]]
@rodolfof

* Structs

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-structs][Ejercicio 14]]

- Coleccion de campos tipados.
- Pueden contener metodos.
- Pero no son clases estrictamente hablando.

Golang favorece la composicion por sobre la herencia:

- [[https://en.wikipedia.org/wiki/Structural_type_system][Structural Typing]]: Como Duck Typing pero en tiempo de compilacion.

- Embedding: [[https://en.wikipedia.org/wiki/Fragile_base_class][The fragile base class problem]].

.code ./resources/src/structs.go

* Structs anidados

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-structs][Ejercicio 14]]

.code ./resources/src/structs-nested.go

* Structs - Metodos

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-structs][Ejercicio 14]]

Un metodo no es mas que una funcion con un argumento receptor especial

.code ./resources/src/structs-methods.go

* Punteros

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-structs][Ejercicio 14]]

- Golang soporta punteros para actualizar valores pero no admite aritmetica de punteros como en C. 
- *** se usa como prefijo para definir un puntero para de un tipo dado.

.code ./resources/src/structs-pointers.go

* Structs compuestos

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-structs][Ejercicio 14]]

[[http://blog.ralch.com/tutorial/design-patterns/golang-composite/][Composition Design Pattern]]

.code ./resources/src/structs-composed.go

* Interfaces

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/15-interfaces][Ejercicio 15]]

- El feature mas importante del lenguaje segun Rob Pike.
- Extensamente usadas en la standard library.
- Es una manera de soportar metodos genericos.
- Se puede hacer composicion de interfaces.
- *No* *es* *necesario* *de* *implementarlas* *explicitamente*.

Lo mas importante de las interfaces es la cultura detras de ellas, piezas de codigo chicas que abstraen funcionalidades.

- "Be conservative in what you send, be liberal in what you accept"
- "The bigger the interface, the smallest the abstraction"

[[https://youtu.be/F4wUrj6pmSI][Understanding Go Interfaces]]

* Interfaces values

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/15-interfaces/interface-values.go][Ejemplo]]

Los valores de la interfaz pueden considerarse como una tupla de un valor y un tipo concreto, esto se llaman _interface_ _value_:

	(value, type)

- Un _interface_ _value_ contiene un valor de un tipo concreto subyacente especifico.
- Llamar a un metodo en un _interface_ _value_ ejecuta el metodo del mismo nombre en su tipo subyacente.

* The empty interface

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/15-interfaces/empty-interface.go.go][Ejemplo]]

Una interfaz sin metodos se conoce como interfaz vacia:

	interface{}

- Una interfaz vacia puede contener valores de cualquier tipo.
- Las interfaces vacias se usan en codigo que tiene que trabajar con valores de un tipo desconocido. Por ejemplo, _fmt.Print_ recibe argumentos de tipo _interface{}_.

* Type assertions

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/15-interfaces/type-assertions.go][Ejemplo]]

El mecanismo de _type_ _assertion_ provee acceso a los valores concretos de un _interface_ _value_:

	t := i.(T)

La instruccion anterior comprueba que el _interface_ _value_ i contiene el tipo concreto T y asigna el valor a la variable t.

Para comprobar que una interfaz almacena un tipo especifico se usa:

	t, ok := i.(T)

* Type switches

Un _type_ _switch_ es un mecanismo que permite hacer _type_ _assertions_ en serie:

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

* Creacion de tipos - make

- Funcion built-in que se usa unicamente para alocar e inicializar slices, maps o channels.
- Se indica el tipo, el tamaï¿½o y la capacidad.
- Como resultado obtenemos la variable en si, no un puntero.

	slice := make([]int, 0, 10)

* Creacion de tipos - new

- Funcion built-in que se usa para alocar memoria.
- Retorna un puntero al valor.

	type Person struct {
		Name string
		Age  int
	}
	juan := new(Person)

* Creacion de tipos - Struct Types

	var juan Person
	rect.Name = "Juan"
	rect.Age = 40

* Creacion de tipos - Struct Literal y &

La inicializacion implicita mas el _&_ es equivalente a _new_.

	juan := Person{"Juan", 22}
	juanPointer := &Person{Name: "Juan", Age: 22}

* Challenge 2.1

.image ./resources/images/chalenge-accepted.jpg 150 _

Modelar la funcionalidad de un sistema de precios para una aerolinea que calcule los ingresos netos de un vuelo en base a los pasajeros y el precio base del ticket.

El precio base del ticket es el mismo para todos los pasajeros.

Existen 3 tipos de pasajeros:

- Base: Paga el 100% del precio base.
- De ultimo minuto: Paga el 50% del precio base.
- Empleado de la aerolinea: No paga el ticket.

* Challenge 2.2 (Opcional)

.image ./resources/images/chalenge-accepted.jpg 150 _

Crear un _test_ para verificar el codigo creado en el challenge 2.1 anterior.

* Challenge 2.3

.image ./resources/images/chalenge-accepted.jpg 150 _

Agregar un nuevo tipo de pasajero 'empleado de aerolinea de ultimo minuto' cuyo descuento sea la suma de los descuentos de los tipos de pasajero 'empleado de aerolinea' y 'ultimo minuto'.

* Concurrencia - Go-Routines

- Golang provee un mecanismo sencillo para crear un nuevo _"thread"_ [[https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca][*]].
- Se usa el keyword *go* antes de una llamada a una funcion (Go-Routines).

.image ./resources/images/concurrency.png 300 _

* Concurrencia - Channels

- Los Channels son _pipes_ para conectar _goroutines_ concurrentes.
- Sirven para enviar y recibir valores entre dos _goroutines_.

.image ./resources/images/channels.jpg 100 _

.image ./resources/images/concurrency-channels.png 300 _

* Challenge 3

.image ./resources/images/chalenge-accepted.jpg 150 _

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/challenge3][Instrucciones del challenge 3]]

* Programando una API REST - HTTP Router

- Para crear una API REST vamos a usar el paquete [[http://www.gorillatoolkit.org/pkg/mux][gorilla/mux]].
- _gorilla/mux_ implementa un router para asociar _requests_ con _handlers_ (funciones Golang).

Se instala con:

	$ go get -u github.com/gorilla/mux

* Programando una API REST - HTTP Router

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/18-rest-api][Ejercicio 18]]

.code ./resources/src/rest-api.go

* Programando una API REST - JSON Encoding

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/18-rest-api][Ejercicio 18]]

- Para trabajar JSON vamos a usar el paquete [[https://golang.org/pkg/encoding/json/][encoding/json]].
- Se utilizan las funciones *Marshal* y *Encode*.

* Programando una API REST - JSON Encoding

.play -edit -numbers ./resources/src/rest-api-json.go

* Challenge 4

.image ./resources/images/chalenge-accepted.jpg 150 _

Crear una API REST para una aplicacion de recordatorios (To-Do) que contenga todas las funciones [[https://en.wikipedia.org/wiki/Create,_read,_update_and_delete][CRUD]] para la siguiente entidad:

	ID     int
	Title  string
	IsDone bool

Hints:

- Los datos se pueden almacenar en un arreglo.
- La funcion *strconv.Atoi* del paquete *[[https://golang.org/pkg/strconv/][strconv]]* permite convertir un string a un integer.
